;; This file was generated with lein-dalap from
;;
;; src/clj/monads/core.clj @ Tue Jul 23 19:45:42 PDT 2013
;;
(ns monads.core (:refer-clojure :exclude [do seq map]) (:require [clojure.set :as set]))
(defprotocol Monad (do-result [_ v]) (bind [mv f]))
(defprotocol MonadZero (zero [_]) (plus-step [mv mvs]))
(defn plus [[mv & mvs]] (plus-step mv mvs))
(defn- comprehend [f mvs] (let [mv (first mvs) rest-steps (reduce (fn [steps mv] (fn [acc x] (bind mv (partial steps (conj acc x))))) (fn [acc x] (do-result mv (f (conj acc x)))) (reverse (rest mvs)))] (bind mv (partial rest-steps []))))
(defn seq "'Executes' the monadic values in 'mvs' and returns a sequence of the\n   basic values contained in them." ([mvs] (assert (clojure.core/seq mvs) "At least one monadic value is required by monads.core/seq") (seq (first mvs) mvs)) ([m-result mvs] (if (clojure.core/seq mvs) (comprehend identity mvs) (m-result []))))
(defn lift "Converts of function f to a function of monadic arguments\n   returning a monadic value." [f] (fn [& mvs] (comprehend (partial apply f) mvs)))
(defn join "Converts a monadic value containing a monadic value into a 'simple'\n   monadic value." [mv] (bind mv identity))
(defn fmap "Bind the monadic value mv to the function f. Returning (f x) for argument x" [f mv] (bind mv (fn [x] (do-result mv (f x)))))
(defn map "'Executes' the sequence of monadic values resulting from mapping\n   f onto the values xs. f must return a monadic value." [f xs] (seq (clojure.core/map f xs)))
(defn chain "Chains together monadic computation steps that are each functions\n   of one parameter. Each step is called with the result of the previous\n   step as its argument. (m-chain (step1 step2)) is equivalent to\n   (fn [x] (domonad [r1 (step1 x) r2 (step2 r1)] r2))." [steps] (fn [x] (let [mv ((first steps) x) chain (reduce (fn [chain step] (fn [x] (bind (step x) chain))) (partial do-result mv) (reverse (rest steps)))] (bind mv chain))))
(defprotocol MonadWriter "Accumulation of values into containers" (writer-m-empty [_] "return an empty container") (writer-m-add [container value] "add value to container, return new container") (writer-m-combine [container1 container2] "combine two containers, return new container"))
(extend-type List Monad (do-result [_ v] (list v)) (bind [mv f] (mapcat f mv)) MonadZero (zero [_] (list)) (plus-step [mv mvs] (apply concat mv mvs)) MonadWriter (writer-m-empty [_] (list)) (writer-m-add [c v] (conj c v)) (writer-m-combine [c1 c2] (concat c1 c2)))
(extend-type EmptyList Monad (do-result [_ v] (list v)) (bind [mv f] (mapcat f mv)) MonadZero (zero [_] (list)) (plus-step [mv mvs] (apply concat mv mvs)) MonadWriter (writer-m-empty [_] (list)) (writer-m-add [c v] (conj c v)) (writer-m-combine [c1 c2] (concat c1 c2)))
(extend-type PersistentVector Monad (do-result [_ v] [v]) (bind [mv f] (vec (mapcat f mv))) MonadZero (zero [_] []) (plus-step [mv mvs] (vec (apply concat mv mvs))) MonadWriter (writer-m-empty [_] []) (writer-m-add [c v] (conj c v)) (writer-m-combine [c1 c2] (vec (concat c1 c2))))
(defn- lazy-concat ([l] l) ([l ls] (lazy-seq (cond (clojure.core/seq l) (cons (first l) (lazy-concat (rest l) ls)) (clojure.core/seq ls) (lazy-concat (first l) (rest ls)) :else (list)))))
(extend-type Range Monad (do-result [_ v] (list v)) (bind [mv f] (mapcat f mv)) MonadZero (zero [_] []) (plus-step [mv mvs] (lazy-concat mv mvs)) MonadWriter (writer-m-empty [_] (list)) (writer-m-add [c v] (conj c v)) (writer-m-combine [c1 c2] (concat c1 c2)))
(extend-type LazySeq Monad (do-result [_ v] (list v)) (bind [mv f] (mapcat f mv)) MonadZero (zero [_] []) (plus-step [mv mvs] (lazy-concat mv mvs)) MonadWriter (writer-m-empty [_] (list)) (writer-m-add [c v] (conj c v)) (writer-m-combine [c1 c2] (concat c1 c2)))
(extend-type PersistentHashSet Monad (do-result [_ v] (hash-set v)) (bind [mv f] (apply set/union (clojure.core/map f mv))) MonadZero (zero [_] #{}) (plus-step [mv mvs] (apply set/union mv mvs)) MonadWriter (writer-m-empty [_] #{}) (writer-m-add [c v] (conj c v)) (writer-m-combine [c1 c2] (clojure.set/union c1 c2)))
(declare maybe-zero-val)
(deftype maybe-monad [v] IDeref (-deref [_] v) Monad (do-result [_ v] (maybe-monad. v)) (bind [mv f] (if (= mv maybe-zero-val) maybe-zero-val (f (clojure.core/deref mv)))) MonadZero (zero [_] maybe-zero-val) (plus-step [mv mvs] (let [mv (->> (cons mv mvs) (drop-while (fn* [p1__1287#] (= maybe-zero-val p1__1287#))) first)] (if (nil? mv) maybe-zero-val mv))))
(def maybe-zero-val (maybe-monad. :user/nothing))
(defn maybe "Monad describing computations with possible failures. Failure is\n   represented by nil, any other value is considered valid. As soon as\n   a step returns nil, the whole computation will yield nil as well." [v] (maybe-monad. v))
(deftype state-monad [v mv f] IFn (-invoke [_ s] (if f (let [[v ss] (mv s)] ((f v) ss)) [v s])) Monad (do-result [_ v] (state-monad. v nil nil)) (bind [mv f] (state-monad. nil mv f)))
(defn state "Monad describing stateful computations. The monadic values have the\n   structure (fn [old-state] [result new-state])." [v] (state-monad. v nil nil))
(deftype StateMonadFn [f] IFn (-invoke [_ s] [s (f s)]) Monad (do-result [_ v] (state-monad. v nil nil)) (bind [mv f1] (state-monad. nil mv f1)))
(defn update-state "Return a state-monad value that replaces the current state by the\n   result of f applied to the current state and that returns the old state." [f] (StateMonadFn. f))
(defn set-state "Return a state-monad value that replaces the current state by s and\n   returns the previous state." [s] (update-state (constantly s)))
(defn get-state "Return a state-monad value that returns the current state and does not\n   modify it." [] (update-state identity))
(defn get-val "Return a state-monad value that assumes the state to be a map and\n   returns the value corresponding to the given key. The state is not modified." [key] (bind (get-state) (fn* [p1__1288#] (state (get p1__1288# key)))))
(defn update-val "Return a state-monad value that assumes the state to be a map and\n   replaces the value associated with the given key by the return value\n   of f applied to the old value and args. The old value is returned." [key f & args] (bind (update-state (fn* [p1__1289#] (apply update-in p1__1289# [key] f args))) (fn* [p1__1290#] (state (get p1__1290# key)))))
(defn set-val "Return a state-monad value that assumes the state to be a map and\n   replaces the value associated with key by val. The old value is returned." [key val] (update-val key (constantly val)))
(defn get-in-val [path & [default]] (bind (get-state) (fn* [p1__1291#] (state (get-in p1__1291# path default)))))
(defn assoc-in-val [path val] (bind (update-state (fn* [p1__1292#] (assoc-in p1__1292# path val))) (fn* [p1__1293#] (state (get-in p1__1293# path)))))
(defn update-in-val [path f & args] (bind (update-state (fn* [p1__1294#] (apply update-in p1__1294# path f args))) (fn* [p1__1295#] (state (get-in p1__1295# path)))))
(deftype cont-monad [v mv f] IDeref (-deref [mv] (mv identity)) IFn (-invoke [_ c] (if f (mv (fn [v] ((f v) c))) (c v))) Monad (do-result [_ v] (cont-monad. v nil nil)) (bind [mv f] (cont-monad. nil mv f)))
(defn cont "Monad describing computations in continuation-passing style. The monadic\n   values are functions that are called with a single argument representing\n   the continuation of the computation, to which they pass their result." [v] (cont-monad. v nil nil))
(defn call-cc "A computation in the cont monad that calls function f with a single\n   argument representing the current continuation. The function f should\n   return a continuation (which becomes the return value of call-cc),\n   or call the passed-in current continuation to terminate." [f])
(extend-type string MonadWriter (writer-m-empty [_] "") (writer-m-add [c v] (str c v)) (writer-m-combine [c1 c2] (str c1 c2)))
(deftype writer-monad [v accumulator] IDeref (-deref [_] [v accumulator]) Monad (do-result [_ v] (writer-monad. v (writer-m-empty accumulator))) (bind [mv f] (let [[v1 a1] (-deref mv) [v2 a2] (-deref (f v1))] (writer-monad. v2 (writer-m-combine a1 a2)))))
(defn writer "Monad describing computations that accumulate data on the side, e.g. for\n   logging. The monadic values have the structure [value log]. Any of the\n   accumulators from clojure.contrib.accumulators can be used for storing the\n   log data. Its empty value is passed as a parameter." [accumulator] (fn [v] (writer-monad. v accumulator)))
(defn write [m-result val-to-write] (let [[_ a] (-deref (m-result nil))] (writer-monad. nil (writer-m-add a val-to-write))))
(defn listen [mv] (let [[v a :as va] (-deref mv)] (writer-monad. va a)))
(defn censor [f mv] (let [[v a] (-deref mv)] (writer-monad. v (f a))))
(deftype state-transformer [m v mv f alts] IFn (-invoke [_ s] (cond alts (plus (clojure.core/map (fn* [p1__1296#] (p1__1296# s)) alts)) f (bind (mv s) (fn [[v ss]] ((f v) ss))) :else (if (= v (zero (m nil))) v (m [v s])))) Monad (do-result [_ v] (state-transformer. m v nil nil nil)) (bind [mv f] (state-transformer. m nil mv f nil)) MonadZero (zero [_] (state-transformer. m nil (fn [s] (zero (m nil))) (fn [v] (state-transformer. m v nil nil nil)) nil)) (plus-step [mv mvs] (state-transformer. m nil nil nil (cons mv mvs))))
(defn state-t "Monad transformer that transforms a monad m into a monad of stateful\n  computations that have the base monad type as their result." [m] (fn [v] (state-transformer. m v nil nil nil)))
(deftype maybe-transformer [m v] IDeref (-deref [_] v) Monad (do-result [_ v] (maybe-transformer. m (m (maybe v)))) (bind [mv f] (let [v (-deref mv)] (maybe-transformer. m (bind v (fn [x] (if (= x maybe-zero-val) (m maybe-zero-val) (-deref (f (-deref x))))))))) MonadZero (zero [_] (maybe-transformer. m (m maybe-zero-val))) (plus-step [mv mvs] (maybe-transformer. m (bind (-deref mv) (fn [x] (cond (and (= x maybe-zero-val) (empty? mvs)) (m maybe-zero-val) (= x maybe-zero-val) (-deref (plus mvs)) :else (m x)))))))
(defn maybe-t "Monad transformer that transforms a monad m into a monad in which\n   the base values can be invalid (represented by :nothing)." [m] (fn [v] (maybe-transformer. m (m (maybe v)))))
(deftype list-transformer [m v] IDeref (-deref [_] v) Monad (do-result [_ v] (list-transformer. m (m (list v)))) (bind [mv f] (let [v (-deref mv)] (list-transformer. m (bind v (fn [xs] (if (clojure.core/seq xs) (->> xs (map (comp -deref f)) (fmap (partial apply lazy-concat))) (m (quote ())))))))) MonadZero (zero [_] (list-transformer. m (m (quote ())))) (plus-step [mv mvs] (list-transformer. m (reduce (lift concat) (m (quote ())) (clojure.core/map -deref (cons mv mvs))))))
(defn list-t "monad transformer that transforms a monad m into a monad in which\n   the base values are lists." [m] (fn [v] (list-transformer. m (m (list v)))))
(deftype vector-transformer [m v] IDeref (-deref [_] v) Monad (do-result [_ v] (vector-transformer. m (m (vector v)))) (bind [mv f] (let [v (-deref mv)] (vector-transformer. m (bind v (fn [xs] (if (clojure.core/seq xs) (->> xs (map (comp -deref f)) (fmap (partial apply lazy-concat))) (m []))))))) MonadZero (zero [_] (vector-transformer. m (m []))) (plus-step [mv mvs] (vector-transformer. m (reduce (lift (comp vec concat)) (m []) (clojure.core/map -deref (cons mv mvs))))))
(defn vector-t "monad transformer that transforms a monad m into a monad in which\n   the base values are vectors." [m] (fn [v] (vector-transformer. m (m (vector v)))))
(deftype set-transformer [m v] IDeref (-deref [_] v) Monad (do-result [_ v] (set-transformer. m (m (hash-set v)))) (bind [mv f] (let [v (-deref mv)] (set-transformer. m (bind v (fn [xs] (if (clojure.core/seq xs) (->> xs (map (comp -deref f)) (fmap (partial apply lazy-concat))) (m #{}))))))) MonadZero (zero [_] (set-transformer. m (m #{}))) (plus-step [mv mvs] (set-transformer. m (reduce (lift set/union) (m #{}) (clojure.core/map -deref (cons mv mvs))))))
(defn set-t "monad transformer that transforms a monad m into a monad in which\n   the base values are sets." [m] (fn [v] (set-transformer. m (m (hash-set v)))))
(deftype writer-transformer [m mv writer-m] IDeref (-deref [_] mv) Monad (do-result [_ v] (writer-transformer. m (m (writer-m v)) writer-m)) (bind [mv f] (let [mv (-deref mv)] (writer-transformer. m (bind mv (fn [v] (let [[v1 a1] (-deref v)] (bind (-deref (f v1)) (fn [v] (let [[v2 a2] (-deref v)] (m (writer-monad. v2 (writer-m-combine a1 a2))))))))) writer-m))) MonadZero (zero [mv] (let [v (-deref mv)] (writer-transformer. m (zero v) writer-m))) (plus-step [mv mvs] (writer-transformer. m (plus (clojure.core/map -deref (cons mv mvs))) writer-m)))
(defn writer-t [m accumulator] (let [writer-m (writer accumulator)] (fn [v] (writer-transformer. m (m (writer-m v)) writer-m))))